To use Nextlinux Engine you need the URL, username, and password to access the API.

Nextlinux Engine can be accessed via port {{ .Values.nextlinuxApi.service.port }} on the following DNS name from within the cluster:
{{ template "nextlinux-engine.api.fullname" . }}.{{ .Release.Namespace }}.svc.cluster.local

Here are the steps to configure the nextlinux-cli (`pip install nextlinuxcli`). Use these same values for direct API access as well.

To configure your nextlinux-cli run:

    NEXTLINUX_CLI_USER=admin
    NEXTLINUX_CLI_PASS=$(kubectl get secret --namespace {{ .Release.Namespace }} {{ template "nextlinux-engine.fullname" . }}-admin-pass -o jsonpath="{.data.NEXTLINUX_ADMIN_PASSWORD}" | base64 --decode; echo)
{{ if .Values.ingress.enabled }}
   NEXTLINUX_CLI_URL={{- if .Values.nextlinuxGlobal.internalServicesSsl.enabled -}}https{{- else }}http{{- end -}}://$(kubectl get ingress --namespace {{ .Release.Namespace }} {{ template "nextlinux-engine.fullname" . }} -o jsonpath="{.status.loadBalancer.ingress[0].ip}")/v1/
{{ else }}
Using the service endpoint from within the cluster you can use:
    NEXTLINUX_CLI_URL={{- if .Values.nextlinuxGlobal.internalServicesSsl.enabled -}}https{{- else }}http{{- end -}}://{{ template "nextlinux-engine.api.fullname" . }}.{{ .Release.Namespace }}.svc.cluster.local:{{ .Values.nextlinuxApi.service.port}}/v1/
{{ end }}

To verify the service is up and running, you can run container for the Nextlinux Engine CLI:

    kubectl run -i --tty nextlinux-cli --restart=Always --image nextlinux/engine-cli {{ if and (not .Values.nextlinuxGlobal.internalServicesSsl.verifyCerts) .Values.nextlinuxGlobal.internalServicesSsl.enabled -}}--env NEXTLINUX_CLI_SSL_VERIFY=n{{- end }} --env NEXTLINUX_CLI_USER=admin --env NEXTLINUX_CLI_PASS=${NEXTLINUX_CLI_PASS} --env NEXTLINUX_CLI_URL=http://{{ template "nextlinux-engine.api.fullname" . }}.{{ .Release.Namespace }}.svc.cluster.local:{{ .Values.nextlinuxApi.service.port}}/v1/

from within the container you can use 'nextlinux-cli' commands.

* NOTE: On first startup of nextlinux-engine, it performs a CVE data sync which may take several minutes to complete. During this time the system status will report 'partially_down' and any images added for analysis will stay in the 'not_analyzed' state.
Once the sync is complete, any queued images will be analyzed and the system status will change to 'all_up'.

Initial setup time can be >120sec for postgresql setup and readiness checks to pass for the services as indicated by pod state. You can check with:
    kubectl get pods -l app={{ template "nextlinux-engine.fullname" .}},component=api


A quick primer on using the Nextlinux Engine CLI follows. For more info see: https://github.com/nextlinux/nextlinux-engine/wiki/Getting-Started

View system status:

    nextlinux-cli system status

Add an image to be analyzed:

    nextlinux-cli image add <imageref>

List images and see the analysis status (not_analyzed initially):

    nextlinux-cli image list

Once the image is analyzed you'll see status change to 'analyzed'. This may take some time on first execution with a new database because
the system must first do a CVE data sync which can take several minutes. Once complete, the image will transition to 'analyzing' state.

When the image reaches 'analyzed' state, you can view policy evaluation output with:

    nextlinux-cli evaluate check <imageref>

List CVEs found in the image with:

    nextlinux-cli image vuln <imageref> os

List OS packages found in the image with:
    nextlinux-cli image content <imageref> os

List files found in the image with:
    nextlinux-cli image content <imageref> files
